#nullable enable
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;
using AnimaBattler.Data;
using AnimaBattler.Core.Anima; // Color, PartSlot

namespace AnimaBattler.Seeder;

public static class AnimaStarterSeeder
{
    // Preferred codes by color & slot (first available will be used)
    private static readonly Dictionary<Color, Dictionary<PartSlot, string[]>> Pref = new()
    {
        [Color.Gray] = new()
        {
            [PartSlot.A] = new[] { "A1" },               // Shield Slam
            [PartSlot.B] = new[] { "B2", "B1" },         // Barrier Field -> Fortify
            [PartSlot.C] = new[] { "C3", "C1" },         // Brace Formation -> Stalwart Push
            [PartSlot.D] = new[] { "D2", "D3", "D1" },   // Unyielding -> Stone Ward -> Last Stand (non-death)
        },
        [Color.Red] = new()
        {
            [PartSlot.A] = new[] { "A1", "A3" },         // Brutal Slash -> Lunge Assault
            [PartSlot.B] = new[] { "B1", "B3", "B2" },   // Momentum Drive -> Puncture Hit -> Battle Rhythm
            [PartSlot.C] = new[] { "C2", "C3", "C1" },   // Piercing Arrow -> Suppressing Volley -> Marking Shot
            [PartSlot.D] = new[] { "D1", "D2", "D4" },   // Frenzy Strike -> Overdrive Rage -> Adrenaline Burst
        },
        [Color.Green] = new()
        {
            [PartSlot.A] = new[] { "A1", "A4" },         // Venom Slash -> Withering Cut
            [PartSlot.B] = new[] { "B2", "B1", "B4" },   // Rejuvenation Burst -> Leeching Strike -> Gentle Purification
            [PartSlot.C] = new[] { "C1", "C2", "C4" },   // Spore Wave -> Bloom Weave -> Withering Spores
            [PartSlot.D] = new[] { "D2", "D3", "D4" },   // Life Surge -> Desiccating Slash -> Verdant Bloom
        },
    };

    public static async Task SeedThreeStartersAsync(GameDbContext db)
    {
        // Archetypes keyed by enum Color
        var archByColor = (await db.Archetypes.AsNoTracking().ToListAsync())
            .ToDictionary(a => a.Color);

        foreach (var c in new[] { Color.Gray, Color.Red, Color.Green })
            if (!archByColor.ContainsKey(c))
                throw new InvalidOperationException($"Archetype '{c}' missing â€” seed archetypes first.");

        // Upsert three pure animas
        var plan = new (Color Color, string Name)[]
        {
            (Color.Gray,  "Aegis"),
            (Color.Red,   "Blaze"),
            (Color.Green, "Verdant"),
        };

        var existing = await db.Animas
            .Where(a => plan.Select(p => p.Name).Contains(a.Name))
            .ToListAsync();
        var byName = existing.ToDictionary(a => a.Name, StringComparer.OrdinalIgnoreCase);

        foreach (var (color, name) in plan)
        {
            if (!byName.TryGetValue(name, out var anima))
            {
                var arch = archByColor[color];
                anima = new AnimaEntity
                {
                    // Id (long) auto-generated by DB
                    Name = name,
                    Color = color,
                    Level = 1,
                    Hp = arch.BaseHp,
                    DamageMultiplier = arch.DamageMult,
                    Description = $"Starter {color} anima."
                };
                db.Animas.Add(anima);
                byName[name] = anima;
            }
            else
            {
                var arch = archByColor[color];
                anima.Color = color;
                if (anima.Hp <= 0) anima.Hp = arch.BaseHp;
                if (anima.DamageMultiplier <= 0) anima.DamageMultiplier = arch.DamageMult;
            }
        }

        await db.SaveChangesAsync();

        // All skills (assumes SkillEntity.Part : PartSlot, SkillEntity.Type : string)
        var allSkills = await db.Skills.AsNoTracking().ToListAsync();

        static bool IsDeathTrigger(SkillEntity s)
        {
           return s.Type == PartType.DeathTrigger;
        }

       SkillEntity? PickForSlot(Color color, long archetypeId, PartSlot slot)
        {
            var pool = allSkills
                .Where(s => s.ArchetypeId == archetypeId && s.Slot == slot)
                .ToList();

            if (slot == PartSlot.D)
                pool = pool.Where(s => !IsDeathTrigger(s)).ToList();

            if (Pref.TryGetValue(color, out var bySlot) && bySlot.TryGetValue(slot, out var prefCodes))
            {
                foreach (var code in prefCodes)
                {
                    var hit = pool.FirstOrDefault(s => string.Equals(s.Code, code, StringComparison.OrdinalIgnoreCase));
                    if (hit != null) return hit;
                }
            }

            return pool
                .OrderBy(s => s.Energy)
                .ThenBy(s => s.Code, StringComparer.Ordinal)
                .FirstOrDefault();
        }


        var order = new[] { PartSlot.A, PartSlot.B, PartSlot.C, PartSlot.D };

        foreach (var (color, name) in plan)
        {
            var anima = byName[name];
            var arch = archByColor[color];

            var chosen = order.Select(slot => PickForSlot(color, arch.Id, slot)).ToList();

            for (int i = 0; i < chosen.Count; i++)
            {
                var s = chosen[i];
                if (s == null) continue;

                bool exists = await db.AnimaSkills
                    .AnyAsync(x => x.AnimaId == anima.Id && x.SkillId == s.Id);

                if (!exists)
                {
                    db.AnimaSkills.Add(new AnimaSkillEntity
                    {
                        AnimaId = anima.Id,       // long
                        SkillId = s.Id,           // long
                        IsEquipped = i < 3,       // equip A/B/C
                        OrderIndex = i,
                        LearnedAtUtc = DateTime.UtcNow
                    });
                }
                else
                {
                    var link = await db.AnimaSkills
                        .FirstAsync(x => x.AnimaId == anima.Id && x.SkillId == s.Id);
                    link.IsEquipped = i < 3;
                    link.OrderIndex = i;
                }
            }
        }

        await db.SaveChangesAsync();
    }
}
